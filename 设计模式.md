#  设计模式

一，迭代器模式



# IDEA

快捷键：

alt + insert 构造器快捷键

shift +enter光标移到下一行

在接口名上 Alt + enter ：快速新建实现类

在；前 alt + enter：强转数据类型

# 单词意思

- invoke调用

# 面试题

1. 深拷贝与浅拷贝

不管是深拷贝还是浅拷贝，拷贝的都是对象，这也是创建对象的一种方式，对象克隆无外乎就是直接赋值**、**浅拷贝**、**深拷贝这三种方式。直接赋值就比如说，

```java 
Person person = new Person();
Person person1 = person;
```

这里栈中的person与person1变量指向堆中的，其实是同一个对象，没有生产新的对象，只是生新增了一个对象引用

而深浅拷贝，拷贝完在堆中会是各指向各自的对象，当然你要想复制，肯定是要实现Clonable接口，然后重写Object中的clone()方法，将权限从protected改为public 。

那深浅拷贝的不同，从字面上就可以看出，是在于拷贝的程度是不一样的，

**浅拷贝：**如果原型对象的成员变量是值类型（8种基本数据类型），将复制一份给克隆对象，也就是说在堆中拥有独立的空间；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。

当然这里比较特殊的 String和Integer这种不可变类型的除外。

引用数据类型：类、接口、数组

 **深拷贝：**，是一种完全拷贝，无论是值类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象，实现的话，很自然地会想到，我再把引用对象实现Clonable接口，将引用对象也克隆一次不就行了，但是这里就涉及到多层克隆的问题

```text
    Person person = (Person)super.clone();
        // 需要将引用对象也克隆一次
        person.personDesc = (PersonDesc) personDesc.clone();
        return person;
```

那么另一种实现深拷贝的方法就是Serializable 序列化的方式